So far,
the queueing systems in the examples did not
have the possibility to provide service based
upon job features other that its arrival
or required service time.
In {\em multiclass\/} ({\em QoS}, {\em discriminatory\/})
queueing systems,
jobs are treated differently based upon their {\em class\/}
({\em priority\/}).
In order to prevent name clashes with \lstinline|Java|
terminology, we shall consistently use the term
{\em Qos queueing systems\/} to refer to them.
More details on QoS queueing systems are provided
in Section \ref{sec:multiclass}.

In \lstinline-jqueues-, 
the most common QoS queueing systems
like Head-of-the-Line and Priority Queueing
have been implemented.
But their implementation is generic in the sense that
you get to ({\em have to\/})
choose the set of "QoS values" for the jobs,
or, in Java terminology,
\lstinline|class|.
From hereon,
we shall refer to this "set of admissible QoS values"
as the \lstinline|QoS class|
of the queue or job,
and its specific value on an entity
as the \lstinline|QoS value|.
On an simulation entity,
you can obtain the \lstinline|QoS class|
and the \lstinline|QoS value|
through the member functions
\lstinline|getQoSClass| and \lstinline|getQoSValue|.
(Clearly,
simulation entities have been designed
with QoS support in mind
from the start.)
Note that the \lstinline|QoS value| of a queue
is to be interpreted as
the {\em default\/} value;
to assign to jobs that have a \lstinline|null|
value (which is allowed),
or a non-supported \lstinline|QoS class|.
There are specific rules as to when it is allowed
to change the \lstinline|QoS class|
and/or \lstinline|QoS value|
of an entity, but we will not go into the details here.
Suffice it to say that you should not change these
settings on queues at all,
but that it is safe to set them on jobs
{\em in between queue visits}.

In our example, we choose Priority Queueing (\lstinline|PQ|)
to demonstrate some of the features of QoS queues and jobs\footnote{
	In the example, for simplicity,
	we leave out the so-called {\em generic-type arguments\/}
	of \lstinline|PQ|.
	Their use is, however, highly recommended.}
In \lstinline|PQ|,
only a single job is served at any time,
and it is always the (a) job with the "highest priority".
Arriving jobs with a strictly higher priority
than the job in service will preempt that job,
which will {\em resume\/} service when it is the
highest-priority job again
(in virtue of the \lstinline|RESUME|
preemption strategy).
In \lstinline|jqueues| we follow
the somewhat unfortunate convention
that {\em the smaller the \lstinline|QoS value|,
	the higher the priority!\/}
For QoS, we choose \lstinline|Java|'s \lstinline|Double|.
We show the example in Listing \ref{simExample6_qos_main}.
The most important difference with non-QoS systems,
is that the \lstinline|QoS class|
and \lstinline|QoS value| have to be provided upon construction
of the queue, and upon construction of the
(specific) \lstinline|DefaultSimJobQoS|.
We create four jobs, numbered $1$ through $4$,
and set their (fixed) respective \lstinline|QoS value|s
to $-1$ to $-4$.
This implies that job $1$ has the lowest priority,
and job $4$ the highest.
We show the program's output in Listing \ref{simExample6_qos_out}.
We indeed see that job $2$ preempts job $1$ upon its arrival,
job $3$ preempts job $2$, and job $4$ preempts job $3$.
Upon completion of job $4$ at $t=7$,
job $3$ is resumed for its remaining service time $4-1=3$,
and hence leaves the system at $t=10$.
Note that the queue does {\em not\/} issue notifications
as to which job is {\em resumed\/}!

\begin{lstfloat}
	\begin{lstlisting}[
	caption={Example of the use of \texttt{QoS}
	queues and jobs.},
	label=simExample6_qos_main,
	basicstyle=\tiny]
	
	final SimEventList el = new DefaultSimEventList ();
	final PQ queue = new PQ (el, PreemptionStrategy.RESUME, Double.class, Double.NEGATIVE_INFINITY);
	queue.registerStdOutSimEntityListener ();
	el.reset (0.0);
	for (int j = 1; j <= 4; j++)
	{
	final double jobServiceTime = 12.0 / j;
	final double jobArrivalTime = (double) j;
	final String jobName = Integer.toString (j);
	final SimJob job = new DefaultSimJobQoS (null, jobName, jobServiceTime, Double.class, (double) (-j));
	SimJQEventScheduler.scheduleJobArrival (job, queue, jobArrivalTime);
	}
	el.run ();
	
	\end{lstlisting}
\end{lstfloat}

\begin{lstfloat}
	\begin{lstlisting}[
	caption={The output of Listing \ref{simExample6_qos_main}.},
	label=simExample6_qos_out,
	basicstyle=\tiny]
	
	StdOutSimEntityListener t=0.0, entity=PQ[RESUME]: STATE CHANGED:
	=> RESET [Reset@PQ[RESUME]]
	StdOutSimEntityListener entity=PQ[RESUME]: RESET.
	StdOutSimEntityListener t=1.0, entity=PQ[RESUME]: UPDATE.
	StdOutSimEntityListener t=1.0, entity=PQ[RESUME]: STATE CHANGED:
	=> ARRIVAL [Arr[1]@PQ[RESUME]]
	=> START [Start[1]@PQ[RESUME]]
	=> STA_FALSE [StartArmed[false]@PQ[RESUME]]
	StdOutSimEntityListener t=2.0, entity=PQ[RESUME]: UPDATE.
	StdOutSimEntityListener t=2.0, entity=PQ[RESUME]: STATE CHANGED:
	=> ARRIVAL [Arr[2]@PQ[RESUME]]
	=> START [Start[2]@PQ[RESUME]]
	StdOutSimEntityListener t=3.0, entity=PQ[RESUME]: UPDATE.
	StdOutSimEntityListener t=3.0, entity=PQ[RESUME]: STATE CHANGED:
	=> ARRIVAL [Arr[3]@PQ[RESUME]]
	=> START [Start[3]@PQ[RESUME]]
	StdOutSimEntityListener t=4.0, entity=PQ[RESUME]: UPDATE.
	StdOutSimEntityListener t=4.0, entity=PQ[RESUME]: STATE CHANGED:
	=> ARRIVAL [Arr[4]@PQ[RESUME]]
	=> START [Start[4]@PQ[RESUME]]
	StdOutSimEntityListener t=7.0, entity=PQ[RESUME]: UPDATE.
	StdOutSimEntityListener t=7.0, entity=PQ[RESUME]: STATE CHANGED:
	=> DEPARTURE [Dep[4]@PQ[RESUME]]
	StdOutSimEntityListener t=10.0, entity=PQ[RESUME]: UPDATE.
	StdOutSimEntityListener t=10.0, entity=PQ[RESUME]: STATE CHANGED:
	=> DEPARTURE [Dep[3]@PQ[RESUME]]
	StdOutSimEntityListener t=15.0, entity=PQ[RESUME]: UPDATE.
	StdOutSimEntityListener t=15.0, entity=PQ[RESUME]: STATE CHANGED:
	=> DEPARTURE [Dep[2]@PQ[RESUME]]
	StdOutSimEntityListener t=26.0, entity=PQ[RESUME]: UPDATE.
	StdOutSimEntityListener t=26.0, entity=PQ[RESUME]: STATE CHANGED:
	=> DEPARTURE [Dep[1]@PQ[RESUME]]
	=> STA_TRUE [StartArmed[true]@PQ[RESUME]]
	
	\end{lstlisting}
\end{lstfloat}

With the description of \lstinline|QoS| queueing systems,
we have completed our first glance at the \lstinline|SimQueue|
and \lstinline|SimJob| interfaces.
Before turning our attention to somewhat more advanced features like
{\em composite queues},
we want to summarize the complete \lstinline|SimQueue| interface in the next section.
