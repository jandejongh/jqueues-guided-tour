If you have read this tour linearly,
  and have reached this point,
  you have mastered most of the essential features
  of \lstinline|jqueues| and \lstinline|jsimulation|.
In the current and next section,
  we cover two aspects that you may want to skip at first reading,
  viz., {\em composite\/} queues in the next section,
  and {\em atomicity\/} and {\em queue invariants\/} in this section.
They are, however, signature features of \lstinline|jqueues|.

As mentioned many times earlier,
  every \lstinline|SimEntity|
  supports a well-defined set of operations.
These operations, at least the external ones,
  are invoked from the event list,
  or otherwise from within the \lstinline|SimEntity| itself
  while processing another operation.
The state of a \lstinline|SimEntity| can only change
  as a result of the invocation of an operation on it.
Immediately after an operation invocation has been received,
  the \lstinline|SimEntity| must fire
  an \lstinline|UPDATE| notification to its registered
  listeners, exposing the entity's state
  immediately prior to receiving the invocation.
After completion of the operation,
  the \lstinline|SimEntity| must
  fire a \lstinline|STATE CHANGED| notification,
  exposing its new state.
The notification may sometimes be left out if the state
  did not actually change,
  but, many operation invocations are {\em always\/}
  reported to listeners, even if they do not result in state changes
  (for instance, invocations of \lstinline|Arrive|, \lstinline|Drop|,
   \lstinline|Start| and \lstinline|DEPART| on a \lstinline|SimQueue|).

But this you already knew, right? So, there has to be more...
Let's do this, one step at a time.

First, forget about {\em all\/} other notifications
  than \lstinline|RESET|, \lstinline|UPDATE| and \lstinline|STATE CHANGED|.
All other forms or notifications are essentially
  {\em courtesy\/} notifications derived from
  (mostly) \lstinline|STATE CHANGED| notifications.
You may have already discovered that such courtesy notifications
  are always fired {\em after\/} the \lstinline|STATE CHANGED|
  notifications, if at all.
It is essential to realize that a full description
  of the state changes is always available in the \lstinline|STATE CHANGED|
  notification.
It is often harder to process than the courtesy notifications, sure,
  but all courtesy notifications are in essence derived from it.

Second,
  \lstinline|STATE CHANGED| notifications
  consist of a {\em sequence of sub-notifications}.
Because, often,
  the invocation of an event leads to a more
  complicated state change than can be described
  in a single notification:
  Jobs might start upon arrival,
  or be dropped due to queue-access vacations,
  or even depart immediately upon arrival.
This explains why a \lstinline|STATE CHANGED|
  notification comes with a \lstinline|Set|
  of \lstinline|SimEntityEvent|s (in proper sequence),
  each describing a single step in the state transition.

Third, realize that invocations of an operation
  come in two flavors: An initial invocation
  from the event list, and, if applicable, subsequent
  invocations while processing that
  initial invocation.
(These subsequent invocations are almost always for {\em internal\/}
  operations, but this is by no means a requirement of even the general case.)
We refer to the initial revocation as the {\em top-level operation (invocation)},
  and the others as {\em chained operation invocations},
  or shortly (and sloppily) {\em chained operations}.

We have now set the stage for the big one:
  {\em Top-level operation invocations are processed atomically.}
Meaning? Well, in simple terms, only the top-level operation
  is allowed to notify listeners,
  and only after the new state has been achieved completely.
So, upon completion of a chain operation,
  its relevant notifications are deferred until
  the top-level notification has finished completely.

Why should we care? Well, consider the following example:
  We schedule at $t=0$, a single arrival of a single job
  requiring $1.0$ service time
  at an
  otherwise empty \lstinline|FCFS| queue.
There are no queue-access vacations,
  and the queue has unlimited
  server-access credits
  (both are default settings).
When the event list processes the event,
  we know what happens:
  The job arrives,
  enters the waiting area,
  and, because the server is idle,
  the job starts immediately.
Nothing new...
But: The scheduled \lstinline|Arrive| operation
  is top-level, the resulting \lstinline|Start| operation
  is chained, and therefore not allowed to issue notifications
  by itself.
This means that upon return from the \lstinline|Arrive| operation,
  we get a combined (using an improvised notation)
  \lstinline|STATE CHANGED[ARRIVAL, START]| notification,
  instead of two separate ones,
  \lstinline|STATE CHANGED[ARRIVAL]|
  followed by \lstinline|STATE CHANGED[START]|.

So what is the big deal?
Well, in order to appreciate atomicity of top-level operation invocations,
  we need the concept of a {\em queue invariant},
  being a statement about a queue (\lstinline|SimQueue|)
  that should {\em always\/} hold.
In this particular case for \lstinline|FCFS|,
  we do not expect jobs residing in the waiting area
  if the service area is empty
  (and server-access credits are available).
Hence, a properly formulated queue invariant
  for \lstinline|FCFS| (and many other queueing systems) is:
  {\em If the service area is empty and the queue has non-zero
       server-access credits, then its waiting area is empty}.
In other words: "There cannot be waiting jobs if the server is idle".

So, continue please?
Well, in \lstinline|jqueues|,
  {\em queue invariants are always \lstinline|true| when notifications are fired}.
This is an essential, and in many ways distinguising feature of \lstinline|jqueues|.
It means that \lstinline|SimQueue| implementations can document
  their invariants,
  and listeners are sure that these invariants are always met.
This is hard if not impossible (in general) without requiring atomicity on
  the invocation of operations.

In order to appreciate this,
  let's consider an alternative approach to implementing \lstinline|SimQueue|
  (well, in fact, let's consider a different {\em interface\/}).
The straightforward strategy we actually used in earlier versions
  of \lstinline|jqueues| is to always {\em schedule\/}
  the \lstinline|Start| operation on the event list
  on a \lstinline|FCFS| queue.
The implementation is really a whole lot simpler:
  Upon the arrival of a job,
  the job is added to the tail of the waiting area
  and if it is the only one in the waiting area,
  a \lstinline|Start| event is scheduled on the event list,
  obviously with the same event time as the arrival time.
The scheduled \lstinline|Start| operation,
  once invoked,
  takes the job out of the waiting area,
  adds it to the service area,
  and schedules the invocation of
  its \lstinline|Depart| operation.
The \lstinline|Depart| operation then
  removes the job from the service area,
  as well as taking other actions to
  end the visit.
And, lo and behold,
  the approach works just fine.
So simple...
But: The \lstinline|Arrive| and \lstinline|Start|
  operation must obviously report
  their inflicted state changes to the registered listeners.
This means that
  \lstinline|Arrive| notifies its listeners with an \lstinline|ARRIVAL|
  notification with the newly arrived job's
  shining presence in the waiting area.
Sure,
  it will be gone a jiffie (not even that much) later,
  but the listeners are exposed to a state
  that is a violation of an all but reasonable
  queue invariant.
It exposes the job in the waiting area while
  the service area is empty...

So, you create a much more complicated interface and
  implementation of a \lstinline|SimQueue|
  (even of a \lstinline|SimEntity|)
  just to achieve that
  a queue does not expose itself to listeners
  in a state inconsistent with the queue invariant?
Are they that important?
Well, yes! They are really that important...

By the way,
  the \lstinline|FCFS| queue has an additional queue invariant:
  its service area does not contain jobs with zero
  required service time.
So if the job in the example would indeed require no
  service, the notification in response to
  the invocation of the \lstinline|Arrive| operation
  would indeed be \lstinline|STATE CHANGED[ARRIVAL, START, DEPARTURE]|.

The realization that top-level events (again, sloppy) should
  be processed atomically was of critical importance
  for the implementation of {\em composite queues\/};
  queues that consists of the combination of other
  queues, the so-called sub-queues.
We will introduce them in the next section.
